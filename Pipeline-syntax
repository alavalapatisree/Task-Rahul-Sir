A Jenkinsfile can be written using two types of syntax — Declarative and Scripted.
Declarative Pipeline is a more recent feature of Jenkins Pipeline which:
  * Provides richer syntactical features over Scripted Pipeline syntax, and
  * Is designed to make writing and reading Pipeline code easier.

Durable: Pipelines can survive both planned and unplanned restarts of the Jenkins controller, but freestyle job can't.

PIPELINE CONCEPTS ==

Pipeline - pipeline is a set of definitions that allows you to automate the processes of Continuous Integration (CI) and Continuous Delivery (CD).
Node - node represents an environment (often a machine or a container) where the steps of a pipeline can be executed.
Stage - stage is a phase or section of your overall pipeline, and within each stage, you can define multiple "steps."
Step - A single task. Fundamentally, a step tells Jenkins what to do at a particular point in time.


options {
    skipStagesAfterUnstable()
}
-----If any stage is unstable, then the stages after unstable stage is skipped.
(Unstable in jenkins means -  stage is completed but some non-critical issues are detected ---Test failures, Code quality Metrics)

A Pipeline can be created in one of the following ways:

1) Through Blue Ocean - after setting up a Pipeline project in Blue Ocean, the Blue Ocean UI helps you write your Pipeline’s Jenkinsfile and commit it to source control.
2) Through the classic UI - you can enter a basic Pipeline directly in Jenkins through the classic UI.
3) In SCM - you can write a Jenkinsfile manually, which you can commit to your project’s source control repository.

A Jenkinsfile created using the classic UI is stored by Jenkins itself (within the Jenkins home directory).

env -  The env global variable in Jenkins Pipeline provides access to environment variables, allowing you to retrieve information about the environment in which the pipeline is running.
                    def buildId = env.BUILD_ID
                    def jobName = env.JOB_NAME
                    echo "Build ID: ${buildId}, Job Name: ${jobName}"

 params -  the params global variable provides access to all the parameters defined for the pipeline. It exposes these parameters as a read-only map, allowing you to retrieve and use their 
values within your pipeline script.

pipeline {
    agent any

    stages {
        stage('Build') {
            steps {
                echo 'Building..'
            }
        }
        stage('Test') {
            steps {
                echo 'Testing..'
            }
        }
        stage('Deploy') {
            steps {
                echo 'Deploying....'
            }
        }
    }
}

* Jenkinsfile is to be created in root directoy of project.
* Jenkinsfile without an agent directive, it is not capable of doing any work.
* stage diective, steps directive also required for a valid declarative pipeline.

checkout scm
* checkout - this is used to checkout code from source control.
* scm - this is a special variable which instructs the checkout step to clone the specific revision.

Jenkinsfile is not a replacement for an existing build tool such as GNU/Make, Maven, Gradle, etc, but rather can be viewed 
as a glue layer to bind the multiple phases of a project’s development lifecycle (build, test, deploy, etc) together.

pipeline {
    agent any

    stages {
        stage('Build') {
            steps {
                sh 'make'
                archiveArtifacts artifacts: '**/target/*.jar', fingerprint: true
            }
        }
    }
}

* sh 'make'
sh step is used to execute shell commands
sh 'make' means that the Jenkins pipeline will execute the make command
the make command reads a file called Makefile to determine how to build and compile a program. The Makefile contains rules and dependencies that specify how different parts of the program depend on each other and how they should be built.


* archiveArtifacts artifacts: '**/target/*.jar', fingerprint: true
archiveArtifacts: This is a Jenkins Pipeline step used to archive artifacts, making them available for future reference and use.
artifacts: '**/target/*.jar': This specifies the files or patterns of files to be archived.
fingerprint: true: This option is set to true to enable fingerprinting for the archived artifacts. Fingerprinting generates a unique identifier (hash) for each version of the artifact based on its content. 

Archiving artifacts is not a substitute for using external artifact repositories such as Artifactory or Nexus and should be considered only for basic reporting and file archival.

* sh 'make check || true'
make check: Runs the checks or tests specified in the check target of the Makefile.
||: The logical OR operator in shell scripting.
true : A command that always succeeds, used to ensure that the entire command (make test || true) exits successfully, regardless of the success or failure of the make test command.

In the context of a build script, CI/CD pipeline, or any automated build process, it's a common pattern to include || true after a potentially failing command when you want to ensure that the overall process continues, even if a specific step fails.


* junit '**/target/*.xml'
After running your JUnit tests as part of your Jenkins Pipeline, the testing framework likely generates XML files containing detailed information about the test results.
The junit step is a Jenkins Pipeline step specifically designed to process JUnit test results. It takes as an argument a file pattern indicating where to find the JUnit XML files.
The junit step processes the specified JUnit XML files and extracts information about test results.
The results are then displayed in the Jenkins build dashboard, providing a visual representation of which tests passed, which failed, and any additional details about test failures or errors.
