A Jenkinsfile can be written using two types of syntax — Declarative and Scripted.
Declarative Pipeline is a more recent feature of Jenkins Pipeline which:
  * Provides richer syntactical features over Scripted Pipeline syntax, and
  * Is designed to make writing and reading Pipeline code easier.

Durable: Pipelines can survive both planned and unplanned restarts of the Jenkins controller, but freestyle job can't.

PIPELINE CONCEPTS ==

Pipeline - pipeline is a set of definitions that allows you to automate the processes of Continuous Integration (CI) and Continuous Delivery (CD).
Node - node represents an environment (often a machine or a container) where the steps of a pipeline can be executed.
Stage - stage is a phase or section of your overall pipeline, and within each stage, you can define multiple "steps."
Step - A single task. Fundamentally, a step tells Jenkins what to do at a particular point in time.


options {
    skipStagesAfterUnstable()
}
-----If any stage is unstable, then the stages after unstable stage is skipped.
(Unstable in jenkins means -  stage is completed but some non-critical issues are detected ---Test failures, Code quality Metrics)

A Pipeline can be created in one of the following ways:

1) Through Blue Ocean - after setting up a Pipeline project in Blue Ocean, the Blue Ocean UI helps you write your Pipeline’s Jenkinsfile and commit it to source control.
2) Through the classic UI - you can enter a basic Pipeline directly in Jenkins through the classic UI.
3) In SCM - you can write a Jenkinsfile manually, which you can commit to your project’s source control repository.

A Jenkinsfile created using the classic UI is stored by Jenkins itself (within the Jenkins home directory).

env -  The env global variable in Jenkins Pipeline provides access to environment variables, allowing you to retrieve information about the environment in which the pipeline is running.
                    def buildId = env.BUILD_ID
                    def jobName = env.JOB_NAME
                    echo "Build ID: ${buildId}, Job Name: ${jobName}"

 params -  the params global variable provides access to all the parameters defined for the pipeline. It exposes these parameters as a read-only map, allowing you to retrieve and use their 
values within your pipeline script.

pipeline {
    agent any

    stages {
        stage('Build') {
            steps {
                echo 'Building..'
            }
        }
        stage('Test') {
            steps {
                echo 'Testing..'
            }
        }
        stage('Deploy') {
            steps {
                echo 'Deploying....'
            }
        }
    }
}

* Jenkinsfile is to be created in root directoy of project.
* Jenkinsfile without an agent directive, it is not capable of doing any work.
* stage diective, steps directive also required for a valid declarative pipeline.

checkout scm
* checkout - this is used to checkout code from source control.
* scm - this is a special variable which instructs the checkout step to clone the specific revision.

Jenkinsfile is not a replacement for an existing build tool such as GNU/Make, Maven, Gradle, etc, but rather can be viewed 
as a glue layer to bind the multiple phases of a project’s development lifecycle (build, test, deploy, etc) together.

pipeline {
    agent any

    stages {
        stage('Build') {
            steps {
                sh 'make'
                archiveArtifacts artifacts: '**/target/*.jar', fingerprint: true
            }
        }
    }
}

* sh 'make'
sh step is used to execute shell commands
sh 'make' means that the Jenkins pipeline will execute the make command
the make command reads a file called Makefile to determine how to build and compile a program. The Makefile contains rules and dependencies that specify how different parts of the program depend on each other and how they should be built.


* archiveArtifacts artifacts: '**/target/*.jar', fingerprint: true
archiveArtifacts: This is a Jenkins Pipeline step used to archive artifacts, making them available for future reference and use.
artifacts: '**/target/*.jar': This specifies the files or patterns of files to be archived.
fingerprint: true: This option is set to true to enable fingerprinting for the archived artifacts. Fingerprinting generates a unique identifier (hash) for each version of the artifact based on its content. 

Archiving artifacts is not a substitute for using external artifact repositories such as Artifactory or Nexus and should be considered only for basic reporting and file archival.

* sh 'make check || true'
make check: Runs the checks or tests specified in the check target of the Makefile.
||: The logical OR operator in shell scripting.
true : A command that always succeeds, used to ensure that the entire command (make test || true) exits successfully, regardless of the success or failure of the make test command.

In the context of a build script, CI/CD pipeline, or any automated build process, it's a common pattern to include || true after a potentially failing command when you want to ensure that the overall process continues, even if a specific step fails.


* junit '**/target/*.xml'
After running your JUnit tests as part of your Jenkins Pipeline, the testing framework likely generates XML files containing detailed information about the test results.
The junit step is a Jenkins Pipeline step specifically designed to process JUnit test results. It takes as an argument a file pattern indicating where to find the JUnit XML files.
The junit step processes the specified JUnit XML files and extracts information about test results.
The results are then displayed in the Jenkins build dashboard, providing a visual representation of which tests passed, which failed, and any additional details about test failures or errors.


*
when {
    expression {
        currentBuild.result == null || currentBuild.result == 'SUCCESS' 
    }
}

when :  It is used to define conditions under which a stage or block should be executed.
expression: This specifies that the condition is expressed using a Groovy expression.
the currentBuild.result variable is used to access the result of the current build. 
currentBuild.result: currentBuild is a built-in variable in Jenkins that represents the current build. The result property of currentBuild represents the result of the current build.
== null || currentBuild.result == 'SUCCESS': This is the Groovy expression defining the condition.
The condition is true (SUCCESS) if the build result is either null (indicating the build is still running) or if the result is 'SUCCESS'.

SUCCESS: The build is considered successful. All stages and tests have passed without any failures or errors.

FAILURE: The build is considered failed. At least one stage or test has failed.

UNSTABLE: The build is considered unstable. This usually indicates that the build was successful, but some tests or quality criteria are not met. 

${YOUR_JENKINS_URL}/pipeline-syntax/globals#env  --- list of environment variables accessible from within Jenkins Pipeline

BUILD_ID
The current build ID, identical to BUILD_NUMBER for builds created in Jenkins versions 1.597+

BUILD_NUMBER
The current build number, such as "153"

BUILD_TAG
String of jenkins-${JOB_NAME}-${BUILD_NUMBER}. Convenient to put into a resource file, a jar file, etc for easier identification

BUILD_URL
The URL where the results of this build can be found (for example http://buildserver/jenkins/job/MyJobName/17/ )

EXECUTOR_NUMBER
The unique number that identifies the current executor (among executors of the same machine) performing this build. This is the number you see in the "build executor status", except that the number starts from 0, not 1

JAVA_HOME
If your job is configured to use a specific JDK, this variable is set to the JAVA_HOME of the specified JDK. When this variable is set, PATH is also updated to include the bin subdirectory of JAVA_HOME

JENKINS_URL
Full URL of Jenkins, such as https://example.com:port/jenkins/ (NOTE: only available if Jenkins URL set in "System Configuration")

JOB_NAME
Name of the project of this build, such as "foo" or "foo/bar".

NODE_NAME
The name of the node the current build is running on. Set to 'master' for the Jenkins controller.

WORKSPACE
The absolute path of the workspace

* echo "Running ${env.BUILD_ID} on ${env.JENKINS_URL}"


pipeline {
    agent any
    environment {
        CC = 'clang'
    }
    stages {
        stage('Example') {
            environment {
                DEBUG_FLAGS = '-g'
            }
            steps {
                sh 'printenv'
            }
        }
    }
}

environment: Defines environment variables for the entire pipeline. In this case, it sets the CC variable to 'clang'.
environment (within 'Example' stage): Defines environment variables specific to the 'Example' stage. It sets the DEBUG_FLAGS variable to '-g'.
sh 'printenv': Executes the shell command printenv, which prints the environment variables. This step is executed within the 'Example' stage. (cc is global so will also print)


An environment directive used in the top-level pipeline block will apply to all steps within the Pipeline.
An environment directive defined within a stage will only apply the given environment variables to steps within the stage.

